---
title: "Cursor + Gigabrain"
description: "Build trading bots with Gigabrain API in Cursor"
icon: "arrow-pointer"
---

Use Cursor to build trading bots and applications powered by Gigabrain's Intelligence Collective. This guide shows you how to integrate the Gigabrain API into your development workflow with Cursor's AI assistant.

## Prerequisites

- Cursor editor installed
- Gigabrain API key from your [Profile](https://gigabrain.gg/profile)
- Basic knowledge of Python or JavaScript

## Quick Start

<Steps>
  <Step title="Get your API key">
    1. Sign in to [Gigabrain](https://gigabrain.gg/login)
    2. Go to [Profile ‚Üí API Keys](https://gigabrain.gg/profile)
    3. Generate a new API key (format: `gb_sk_...`)
  </Step>

  <Step title="Set up your project">
    Create a new directory for your trading bot:

    ```bash
    mkdir gigabrain-bot
    cd gigabrain-bot
    ```

    Create a `.env` file to store your API key:

    ```bash
    GIGABRAIN_API_KEY=gb_sk_your_key_here
    ```

    <Warning>
    Never commit your API key to version control. Add `.env` to your `.gitignore`.
    </Warning>

  </Step>

  <Step title="Configure Cursor rules">
    Create `.cursor/rules.md` in your project root to teach Cursor about Gigabrain API patterns:

    ````markdown
    # Gigabrain API Development Rules

    ## API Configuration
    - Base URL: `https://api.gigabrain.gg`
    - All endpoints prefixed with `/v1`
    - Authentication: `Authorization: Bearer gb_sk_...`
    - Set timeout to at least 600 seconds for all requests

    ## Response Format
    - All responses have a `content` field (not `message`)
    - For structured data, add "Respond as JSON" to your query
    - Parse the `content` field to access JSON data

    ## Rate Limits
    - 30 requests per minute
    - 1,000 requests per day
    - Monitor `X-RateLimit-Remaining-Minute` header
    - Implement exponential backoff on 429 errors

    ## Best Practices
    - Always use environment variables for API keys
    - Handle errors gracefully (401, 429, 500, 504)
    - Cache responses when appropriate
    - Log session_id for debugging
    - Use structured JSON queries for automation

    ## Example Query Patterns
    - Simple: "What is the price of BTC?"
    - Structured: "Get funding rates for top 10 perps. Respond as JSON array with: symbol, funding_rate, open_interest"
    - Multi-agent: "Analyze ETH on the 4H chart with technical and microstructure analysis"
    ````

  </Step>
</Steps>

## Example: Funding Rate Monitor Bot

Build a bot that monitors funding rates and alerts when they reach extreme levels.

<Tabs>
  <Tab title="Python">
    ```python funding_monitor.py
    import os
    import requests
    import json
    from dotenv import load_dotenv
    import time

    load_dotenv()

    API_KEY = os.getenv("GIGABRAIN_API_KEY")
    BASE_URL = "https://api.gigabrain.gg"

    def get_funding_rates():
        """Fetch funding rates for top perpetual contracts"""
        response = requests.post(
            f"{BASE_URL}/v1/chat",
            headers={
                "Authorization": f"Bearer {API_KEY}",
                "Content-Type": "application/json"
            },
            json={
                "message": "Get funding rates for top 20 perpetual contracts. Respond as JSON array with: symbol, funding_rate, open_interest, long_short_ratio"
            },
            timeout=600
        )

        if response.status_code == 200:
            data = response.json()
            return json.loads(data["content"])
        elif response.status_code == 429:
            retry_after = response.headers.get("Retry-After", 60)
            print(f"Rate limited. Retrying after {retry_after}s")
            time.sleep(int(retry_after))
            return get_funding_rates()
        else:
            raise Exception(f"API Error: {response.status_code}")

    def check_extreme_funding(funding_data, threshold=0.03):
        """Alert on extreme funding rates"""
        alerts = []

        for token in funding_data:
            rate = token["funding_rate"]
            if abs(rate) > threshold:
                direction = "LONG" if rate > 0 else "SHORT"
                alerts.append({
                    "symbol": token["symbol"],
                    "funding_rate": rate,
                    "direction": direction,
                    "open_interest": token["open_interest"],
                    "long_short_ratio": token.get("long_short_ratio")
                })

        return alerts

    def main():
        print("üß† Gigabrain Funding Rate Monitor")
        print("=" * 50)

        funding_data = get_funding_rates()
        alerts = check_extreme_funding(funding_data, threshold=0.02)

        if alerts:
            print(f"\n‚ö†Ô∏è  {len(alerts)} EXTREME FUNDING ALERTS:")
            for alert in alerts:
                print(f"\n{alert['symbol']}:")
                print(f"  Funding Rate: {alert['funding_rate']:.4%}")
                print(f"  Direction: {alert['direction']} crowded")
                print(f"  Open Interest: ${alert['open_interest']:,.0f}")
                print(f"  Long/Short Ratio: {alert.get('long_short_ratio', 'N/A')}")
        else:
            print("\n‚úÖ No extreme funding rates detected")

    if __name__ == "__main__":
        main()
    ```

  </Tab>

  <Tab title="JavaScript">
    ```javascript fundingMonitor.js
    import 'dotenv/config';

    const API_KEY = process.env.GIGABRAIN_API_KEY;
    const BASE_URL = "https://api.gigabrain.gg";

    async function getFundingRates() {
      const response = await fetch(`${BASE_URL}/v1/chat`, {
        method: "POST",
        headers: {
          "Authorization": `Bearer ${API_KEY}`,
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          message: "Get funding rates for top 20 perpetual contracts. Respond as JSON array with: symbol, funding_rate, open_interest, long_short_ratio"
        }),
        signal: AbortSignal.timeout(600000),
      });

      if (response.status === 200) {
        const data = await response.json();
        return JSON.parse(data.content);
      } else if (response.status === 429) {
        const retryAfter = response.headers.get("Retry-After") || 60;
        console.log(`Rate limited. Retrying after ${retryAfter}s`);
        await new Promise(resolve => setTimeout(resolve, retryAfter * 1000));
        return getFundingRates();
      } else {
        throw new Error(`API Error: ${response.status}`);
      }
    }

    function checkExtremeFunding(fundingData, threshold = 0.03) {
      const alerts = [];

      for (const token of fundingData) {
        const rate = token.funding_rate;
        if (Math.abs(rate) > threshold) {
          const direction = rate > 0 ? "LONG" : "SHORT";
          alerts.push({
            symbol: token.symbol,
            funding_rate: rate,
            direction,
            open_interest: token.open_interest,
            long_short_ratio: token.long_short_ratio
          });
        }
      }

      return alerts;
    }

    async function main() {
      console.log("üß† Gigabrain Funding Rate Monitor");
      console.log("=".repeat(50));

      const fundingData = await getFundingRates();
      const alerts = checkExtremeFunding(fundingData, 0.02);

      if (alerts.length > 0) {
        console.log(`\n‚ö†Ô∏è  ${alerts.length} EXTREME FUNDING ALERTS:`);
        for (const alert of alerts) {
          console.log(`\n${alert.symbol}:`);
          console.log(`  Funding Rate: ${(alert.funding_rate * 100).toFixed(4)}%`);
          console.log(`  Direction: ${alert.direction} crowded`);
          console.log(`  Open Interest: $${alert.open_interest.toLocaleString()}`);
          console.log(`  Long/Short Ratio: ${alert.long_short_ratio || 'N/A'}`);
        }
      } else {
        console.log("\n‚úÖ No extreme funding rates detected");
      }
    }

    main().catch(console.error);
    ```

  </Tab>
</Tabs>

## Using Cursor Composer

Cursor's Composer feature is perfect for building complex trading bots with Gigabrain. Here's how to use it effectively:

### Example Prompt for Composer

```
Build a trading signal aggregator that:
1. Fetches Fear & Greed Index from Gigabrain API
2. Gets funding rates for BTC, ETH, SOL
3. Retrieves current narratives with momentum scores
4. Combines all signals into a single "market regime" score
5. Logs results to a JSON file with timestamps

Use the Gigabrain API patterns from .cursor/rules.md
Handle rate limits and errors gracefully
Add proper TypeScript types for all API responses
```

Cursor will use your `.cursor/rules.md` to generate code that follows Gigabrain API best practices.

## Common Integration Patterns

### Pattern 1: Structured Data Queries

Always specify exact fields for consistent responses:

```python
query = """
Get BTC fear and greed index. Respond as JSON with:
fear_greed_index, fear_greed_label, btc_dominance,
altcoin_season_index, market_cap_total
"""
```

### Pattern 2: Error Handling

Implement retry logic for transient errors:

```python
def api_call_with_retry(message, max_retries=3):
    for attempt in range(max_retries):
        try:
            response = requests.post(
                f"{BASE_URL}/v1/chat",
                headers={"Authorization": f"Bearer {API_KEY}"},
                json={"message": message},
                timeout=600
            )

            if response.status_code == 200:
                return response.json()
            elif response.status_code in [500, 503, 504]:
                if attempt < max_retries - 1:
                    time.sleep(2 ** attempt)  # Exponential backoff
                    continue
            else:
                response.raise_for_status()

        except requests.exceptions.Timeout:
            if attempt < max_retries - 1:
                continue
            raise

    raise Exception("Max retries exceeded")
```

### Pattern 3: Rate Limit Monitoring

Track your API usage:

```python
def check_rate_limits(response):
    """Monitor rate limit headers"""
    remaining = response.headers.get("X-RateLimit-Remaining-Minute")
    reset_time = response.headers.get("X-RateLimit-Reset-Minute")

    if remaining and int(remaining) < 5:
        print(f"‚ö†Ô∏è  Only {remaining} requests remaining until {reset_time}")
```

## Next Steps

<CardGroup cols={2}>
  <Card title="Brain API Overview" icon="brain" href="/developers/brain-api-overview">
    Explore all available data types and query patterns
  </Card>

<Card title="REST API Reference" icon="code" href="/developers/introduction">
  Complete API documentation with authentication and endpoints
</Card>

<Card title="Agent Setup" icon="robot" href="/guides/agents-setup">
  Deploy autonomous trading agents on Gigabrain
</Card>

  <Card title="Integrations" icon="plug" href="/guides/integrations">
    Connect Hyperliquid for trade execution
  </Card>
</CardGroup>

<Warning>
  Gigabrain provides market intelligence tools, not financial advice. Always
  implement proper risk management in your trading bots. See the [Risk
  Disclosure](/support/risk-disclosure).
</Warning>
